<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Flipbook — MPASI</title>

  <style>
    :root{
      --bg: #eef1f5;
      --panel: #ffffff;
      --ink: #0b0c0d;
      --muted: #5b626e;
      --ring: rgba(0,0,0,.12);
      --accent: #111827;
      --radius: 22px;
      --shadow: 0 14px 50px rgba(0,0,0,.15);
    }
    .theme-dark{
      --bg: #0b0f14;
      --panel: #0f141b;
      --ink: #f2f4f8;
      --muted: #aab2bf;
      --ring: rgba(255,255,255,.14);
      --accent: #e5e7eb;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, -apple-system, "SF Pro Text", Inter, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color:var(--ink);
      background: radial-gradient(1600px 800px at 50% -300px, #fff 0%, var(--bg) 60%, var(--bg) 100%);
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
      transition: background .25s ease, color .25s ease;
    }

    /* Pseudo fullscreen for mobile fallback */
    .pseudo-fs{
      position: fixed; inset: 0;
      width: 100vw; height: 100dvh;
      overflow: hidden;
      background: var(--bg);
    }

    .shell{display:grid;grid-template-rows:auto 1fr auto;height:100%}

    .nav-top{
      position:sticky; top:0; z-index:40;
      display:flex; align-items:center; justify-content:center;
      padding:10px 12px;
      background:rgba(255,255,255,.75);
      backdrop-filter:saturate(160%) blur(18px);
      border-bottom:1px solid var(--ring);
    }
    .theme-dark .nav-top{ background:rgba(20,24,32,.55) }
    .brand{font-weight:700; letter-spacing:.2px}

    .stage{display:grid;place-items:center;padding:14px}
    .panel{
      width:min(100%, 1280px);
      border-radius:var(--radius);
      background:var(--panel);
      box-shadow: var(--shadow);
      padding:12px;
      overflow:auto;
      transition: background .25s ease, box-shadow .25s ease;
      height: calc(100dvh - 120px); /* kira2: topbar + toolbar */
    }

    .zoom-wrap{
      transform-origin: center top;
      transition: transform .2s ease;
      display:grid;
      place-items:center;
      width:100%;
    }

    #book{
      width: 100%;
      height: 80dvh;       /* gunakan dynamic vh */
      border-radius:16px;
      overflow:hidden;
      background:#fff;
      touch-action: none;  /* stabil untuk pinch/drag */
    }

    .toolbar{
      position:sticky; bottom:0; z-index:45;
      display:flex; align-items:center; justify-content:center; gap:10px;
      padding:10px 12px calc(10px + env(safe-area-inset-bottom));
      background:rgba(255,255,255,.85);
      backdrop-filter:saturate(160%) blur(18px);
      border-top:1px solid var(--ring);
    }
    .theme-dark .toolbar{ background:rgba(20,24,32,.65) }

    .btn{
      appearance:none;border:1px solid var(--ring);background:var(--panel);color:var(--ink);
      padding:12px 14px;border-radius:999px;line-height:1;cursor:pointer;
      box-shadow:0 1px 0 rgba(0,0,0,.02),0 6px 20px rgba(0,0,0,.06);
      transition:transform .06s ease, box-shadow .2s ease, background .2s ease, color .2s ease;
      font-size:16px; min-width:44px; min-height:44px;
    }
    .btn:active{transform:scale(.98)}
    .btn:hover{box-shadow:0 8px 26px rgba(0,0,0,.1)}
    .counter{color:var(--muted);font-size:14px;min-width:90px;text-align:center}
    .range{display:flex;align-items:center;gap:8px}
    input[type="range"]{
      -webkit-appearance:none;appearance:none;width:150px;height:6px;background:#e6e9ee;border-radius:999px;outline:none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;appearance:none;width:20px;height:20px;border-radius:50%;
      background:var(--panel);border:1px solid var(--ring);box-shadow:0 6px 18px rgba(0,0,0,.15);cursor:pointer
    }

    .loading{display:grid;place-items:center;gap:12px;height:80dvh;color:var(--muted)}
    .progress{width:min(420px,70vw);height:8px;background:#e8ebf0;border-radius:999px;overflow:hidden;box-shadow:inset 0 0 1px rgba(0,0,0,.05)}
    .theme-dark .progress{ background:#222833; }
    .bar{height:100%;width:0%;background:var(--accent);transition:width .22s ease}
    .hint{font-size:12px;color:var(--muted)}

    @media (min-width: 900px){
      .shell{grid-template-rows:auto 1fr}
      .toolbar{position:sticky; top:0; bottom:auto; justify-content:flex-end}
      #book{height: 86dvh}
      .panel{height:auto}
    }

    .is-fullscreen #book{ height: 92dvh; }
/* Smooth page transform while flipping */
.page {
  backface-visibility: hidden;
  will-change: transform;
  transition: transform 1s cubic-bezier(0.25, 0.8, 0.25, 1);
}

    
  </style>

  <script src="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/js/page-flip.browser.js" defer></script>

  <!-- PDF.js primary (no defer) + fallback -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.min.js"></script>
  <script>
    (function(){
      if(!window.pdfjsLib){
        var s=document.createElement('script');
        s.src='https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js';
        document.head.appendChild(s);
      }
    })();
  </script>
</head>
<body>
  <div class="shell" id="appShell">
    <div class="nav-top"><div class="brand">Flipbook</div></div>

    <div class="stage">
      <div class="panel" id="panel">
        <div class="zoom-wrap" id="zoomWrap">
          <div id="book">
            <div class="loading" id="loading">
              <div>
                <div style="font-weight:700; font-size:15px; margin-bottom:8px;">Rendering flipbook…</div>
                <div class="progress"><div class="bar" id="bar"></div></div>
                <div class="hint" id="hint">Preparing pages</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="toolbar">
      <button class="btn" id="themeBtn" title="Dark/Light">🌓</button>
      <button class="btn" id="fullBtn" title="Fullscreen">⛶</button>
      <div class="range">
        <button class="btn" id="zoomOut" title="Zoom out">−</button>
        <input id="zoomRange" type="range" min="80" max="220" value="100" />
        <button class="btn" id="zoomIn" title="Zoom in">+</button>
      </div>
      <div class="counter" id="pageCounter">Page 1 / 1</div>
      <button class="btn" id="prevBtn" title="Prev">◀︎</button>
      <button class="btn" id="nextBtn" title="Next">▶︎</button>
    </div>
  </div>

<script>
/* ===== Helpers ===== */
async function waitForPdfjs(){
  for(let i=0;i<40;i++){ if(window.pdfjsLib) return window.pdfjsLib; await new Promise(r=>setTimeout(r,100)); }
  throw new Error('PDF.js failed to load');
}
const isMobile = () => window.matchMedia('(max-width: 900px)').matches;

window.addEventListener('load', async () => {
  const params = new URLSearchParams(location.search);
  const PDF_URL = params.get('file') || "pdf/mpasi.pdf";

  const appShell = document.getElementById('appShell');
  const panel = document.getElementById('panel');
  const zoomWrap = document.getElementById('zoomWrap');
  const zoomRange = document.getElementById('zoomRange');
  const zoomInBtn = document.getElementById('zoomIn');
  const zoomOutBtn = document.getElementById('zoomOut');
  const themeBtn = document.getElementById('themeBtn');
  const fullBtn = document.getElementById('fullBtn');
  const bookEl  = document.getElementById('book');
  const barEl   = document.getElementById('bar');
  const hintEl  = document.getElementById('hint');
  const loadingEl = document.getElementById('loading');
  const counterEl = document.getElementById('pageCounter');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');

  /* ===== Zoom ===== */
  let zoom = 1.0;
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const limits = ()=> isMobile() ? [0.9, 2.2] : [0.8, 2.0];
  const applyZoom = () => { zoomWrap.style.transform = `scale(${zoom})`; zoomRange.value = String(Math.round(zoom*100)); };
  const setZoom = (z)=>{ const [min,max]=limits(); zoom = clamp(z, min, max); applyZoom(); requestRenderVisible(); };
  zoomInBtn.addEventListener('click', ()=> setZoom(zoom + 0.1));
  zoomOutBtn.addEventListener('click', ()=> setZoom(zoom - 0.1));
  zoomRange.addEventListener('input', e=> setZoom(+e.target.value/100));
  zoomWrap.addEventListener('dblclick', ()=> setZoom(zoom < 1.25 ? 1.5 : 1.0));
  // Pinch
  let startDist=null,startZoom=null;
  zoomWrap.addEventListener('touchmove', e=>{
    if(e.touches.length===2){
      const dx=e.touches[0].clientX - e.touches[1].clientX;
      const dy=e.touches[0].clientY - e.touches[1].clientY;
      const dist=Math.hypot(dx,dy);
      if(startDist==null){ startDist=dist; startZoom=zoom; }
      setZoom(startZoom * (dist/startDist));
      e.preventDefault();
    }
  }, {passive:false});
  zoomWrap.addEventListener('touchend', ()=>{ startDist=null; });

  // Theme toggle
  themeBtn.addEventListener('click', ()=> document.body.classList.toggle('theme-dark'));

  // ===== Fullscreen with mobile fallback =====
  const isFs = ()=> document.fullscreenElement || document.webkitFullscreenElement;
  const enterFs = async () => {
    try {
      if (panel.requestFullscreen) await panel.requestFullscreen();
      else if (panel.webkitRequestFullscreen) await panel.webkitRequestFullscreen();
      else throw new Error('no fs');
    } catch(e){
      // Mobile fallback: pseudo fullscreen
      document.body.classList.add('pseudo-fs','theme-dark','is-fullscreen');
    }
  };
  const exitFs  = async () => {
    try {
      if (document.exitFullscreen) await document.exitFullscreen();
      else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
    } catch(e){}
    document.body.classList.remove('pseudo-fs','is-fullscreen');
  };
  fullBtn.addEventListener('click', ()=> isFs() || document.body.classList.contains('pseudo-fs') ? exitFs() : enterFs());
  document.addEventListener('fullscreenchange', ()=>{
    const on = !!isFs();
    document.body.classList.toggle('theme-dark', on);
    document.body.classList.toggle('is-fullscreen', on);
  });

  /* ===== PDF.js ===== */
  let pdfjs;
  try { pdfjs = await waitForPdfjs(); }
  catch(e){ bookEl.innerHTML = "<div style='padding:24px;color:#b91c1c'>Failed to load PDF.js.</div>"; return; }

  const v = pdfjs.version || '';
  if (v.startsWith('4.')) {
    pdfjs.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.worker.min.js";
  } else {
    pdfjs.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
  }

  // Load PDF
  const task = pdfjs.getDocument(PDF_URL);
  const pdf  = await task.promise;
  const pageCount = pdf.numPages;

  // ambil rasio halaman
  const p1 = await pdf.getPage(1);
  const initViewport = p1.getViewport({ scale: 2 });
  const pageRatio = initViewport.width / initViewport.height; // W/H

  // Buat skeleton halaman
  const pageDivs = [], canvases = [];
  const frag = document.createDocumentFragment();
  for (let i = 1; i <= pageCount; i++) {
    const wrapper = document.createElement('div');
    wrapper.className = 'page';
    const canvas = document.createElement('canvas');
    canvas.style.width = '100%'; canvas.style.height = '100%';
    wrapper.appendChild(canvas);
    pageDivs.push(wrapper); canvases.push(canvas); frag.appendChild(wrapper);
    barEl.style.width = ((i / pageCount) * 100).toFixed(1) + "%";
  }
  bookEl.innerHTML = ''; bookEl.appendChild(frag);

  // ==== Responsive sizing for PageFlip (anti-crop) ====
  let pageFlip;
  function computeSize(){
    const containerW = bookEl.clientWidth;
    const containerH = bookEl.clientHeight;
    const portrait = isMobile(); // mobile single page

    if (portrait){
      // Single page: fit both width & height while keep ratio
      let w = containerW;
      let h = w / pageRatio;
      if (h > containerH){ h = containerH; w = h * pageRatio; }
      return {width: Math.max(320, Math.floor(w)), height: Math.max(320, Math.floor(h)), usePortrait:true};
    } else {
      // Spread: two pages side-by-side → total ratio ≈ 2*pageRatio
      // Fit by height first for nicer reading
      let h = containerH;
      let w = Math.min(containerW, Math.floor(h * pageRatio * 2));
      // if width is limiting, recompute height
      if (w < containerW){ /* ok */ } else { h = Math.floor(containerW / (pageRatio * 2)); }
      return {width: Math.max(640, Math.floor(w)), height: Math.max(360, Math.floor(h)), usePortrait:false};
    }
  }

  function setSkeletonSize(w,h){
    for (const el of pageDivs){
      el.style.width  = w + 'px';
      el.style.height = h + 'px';
      el.style.background = '#fff';
    }
  }

  function initFlip(){
  pageFlip = new St.PageFlip(bookEl, {
  width: Math.floor(sz.width / (sz.usePortrait ? 1 : 2)),
  height: Math.floor(sz.height),
  size: "stretch",
  showCover: true,
  drawShadow: true,
  maxShadowOpacity: 0.25,
  flippingTime: 720,            // ← ANGKA INI KITA UBAH
  usePortrait: sz.usePortrait,
  mobileScrollSupport: true,
  minWidth: 320, maxWidth: 3600, minHeight: 320, maxHeight: 5000,
});
  const sz = computeSize();
    setSkeletonSize(Math.floor(sz.width / (sz.usePortrait ? 1 : 2)), Math.floor(sz.height)); // size per-page
    pageFlip = new St.PageFlip(bookEl, {
      width: Math.floor(sz.width / (sz.usePortrait ? 1 : 2)), // per page
      height: Math.floor(sz.height),
      size: "stretch",
      showCover: true,
      drawShadow: true,
      maxShadowOpacity: 0.25,
      flippingTime: 1000,
      usePortrait: sz.usePortrait,
      mobileScrollSupport: true,
      minWidth: 320, maxWidth: 3600, minHeight: 320, maxHeight: 5000,
    });
    pageFlip.loadFromHTML(pageDivs);
    wireFlipEvents();
  }

  function updateFlipSize(){
    const sz = computeSize();
    setSkeletonSize(Math.floor(sz.width / (sz.usePortrait ? 1 : 2)), Math.floor(sz.height));
    pageFlip.update({
      width: Math.floor(sz.width / (sz.usePortrait ? 1 : 2)),
      height: Math.floor(sz.height)
    });
    // force rerender visible after size change
    requestRenderVisible();
  }

  function wireFlipEvents(){
    const updateCounter = () => {
      counterEl.textContent = "Page " + (pageFlip.getCurrentPageIndex() + 1) + " / " + pageFlip.getPageCount();
    };
    pageFlip.on('flip', async ()=>{ updateCounter(); await renderVisible(); });
    pageFlip.on('init', async ()=>{ updateCounter(); await renderVisible(); });
    pageFlip.on('update', async ()=>{ await renderVisible(); });

    prevBtn.addEventListener('click', () => pageFlip.flipPrev());
    nextBtn.addEventListener('click', () => pageFlip.flipNext());

    // Tap/click to flip: left=prev, right=next (abaikan saat pinch)
    let isPinching = false;
    zoomWrap.addEventListener('touchstart', e=>{ if(e.touches.length===2) isPinching=true; }, {passive:true});
    zoomWrap.addEventListener('touchend', ()=>{ isPinching=false; }, {passive:true});
    bookEl.addEventListener('click', (e)=>{
      if (isPinching) return;
      const rect = bookEl.getBoundingClientRect();
      const x = e.clientX - rect.left;
      if (x < rect.width * 0.45) pageFlip.flipPrev();
      else if (x > rect.width * 0.55) pageFlip.flipNext();
    });

    // Swipe kiri/kanan (non-pinch)
    let sx=null, sy=null, moved=false;
    bookEl.addEventListener('touchstart', e=>{ if(e.touches.length===1){ sx=e.touches[0].clientX; sy=e.touches[0].clientY; moved=false; }});
    bookEl.addEventListener('touchmove', e=>{ if(sx!=null && e.touches.length===1){ const dx=Math.abs(e.touches[0].clientX-sx); const dy=Math.abs(e.touches[0].clientY-sy); if(dx>dy) e.preventDefault(); moved=true; }}, {passive:false});
    bookEl.addEventListener('touchend', e=>{
      if(sx!=null && moved){
        const ex=e.changedTouches[0].clientX;
        const delta=ex-sx;
        if(delta<-60) pageFlip.flipNext();
        if(delta>60)  pageFlip.flipPrev();
      }
      sx=sy=null; moved=false;
    });
  }

  initFlip();

  // Resize/orientation changes
  let resizeTimer;
  const onResize = ()=>{
    clearTimeout(resizeTimer);
    resizeTimer=setTimeout(()=>{ updateFlipSize(); }, 120);
  };
  window.addEventListener('resize', onResize);
  window.addEventListener('orientationchange', onResize);

  // ===== On-demand HD render (tajam sesuai zoom & DPR) =====
  const dpr = window.devicePixelRatio || 1;
  async function renderPage(index, z=1) {
    const pageNumber = index + 1;
    if (pageNumber < 1 || pageNumber > pageCount) return;
    const canvas = canvases[index]; if (!canvas) return;
    const ctx = canvas.getContext('2d', { alpha: false });
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    const page = await pdf.getPage(pageNumber);

    // Hitung skala dari ukuran pageFlip saat ini (per halaman)
    const current = pageFlip.getSettings(); // width/height per page
    const baseScale = Math.min(3.0, dpr * 2.25);
    // Normalisasi: viewport scale ≈ (current page height / original height at scale 1) * baseScale * zoom
    const norm = current.height / (initViewport.height); // kira2 baseline
    const scale = Math.min(4.0, baseScale * z * Math.max(1, norm));

    const viewport = page.getViewport({ scale });
    canvas.width  = Math.floor(viewport.width);
    canvas.height = Math.floor(viewport.height);
    await page.render({ canvasContext: ctx, viewport }).promise;
  }

  let renderQueued=false;
  async function renderVisible(){
  const i = pageFlip.getCurrentPageIndex();
  const visible = new Set([i-2, i-1, i, i+1, i+2].filter(n => n>=0 && n<pageCount));
  const m = zoomWrap.style.transform.match(/scale\(([^)]+)\)/);
  const currentZoom = parseFloat(m ? m[1] : '1') || 1;
  await Promise.all(Array.from(visible).map(idx => renderPage(idx, currentZoom)));
}

  }
  function requestRenderVisible(){
    if(renderQueued) return; renderQueued=true;
    requestAnimationFrame(async ()=>{ await renderVisible(); renderQueued=false; });
  }

  // ===== Initial ready =====
  loadingEl.remove();
  setZoom(1.0);
});
</script>
</body>
</html>
